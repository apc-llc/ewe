/****************************************************************/
/*                                                              */
/*                                                              */
/****************************************************************/

#include "Electrocardio.h"

template<>
InputParameters validParams<Electrocardio>()
{
  InputParameters params = validParams<Material>();
  params.addRequiredCoupledVar("vmem","Membrane potential needed as input for ion channel model");
  //! @todo: For ion channel models that need the diffusion current, have to fetch the value of Imem somehow
  return params;
}

Electrocardio::Electrocardio(const std::string & name,
                                 InputParameters parameters) :
  Material(name, parameters),
  _Iion(declareProperty<Real>("Iion")),
  _gates(declareProperty<std::vector<Real> >("gates")),
  _gates_old(declarePropertyOld<std::vector<Real> >("gates")),
  // coupled variables
  _vmem(coupledValue("vmem"))
{
  
  // Create pointer to a Bernus model object using the factory class
  _ionmodel = IionmodelFactory::factory(IionmodelFactory::BERNUS, & gates_qp, & gates_dt_qp);
  
  std::cout << "Constructing Material Electrocardio..." << std::endl;
}

void
Electrocardio::initQpStatefulProperties()
{
  _gates[_qp].resize(_ionmodel->get_ngates());
  _gates_old[_qp].resize(_ionmodel->get_ngates());
  for (int i=0; i<_ionmodel->get_ngates(); ++i) {
    // Initialize with steady-state gate variables
    _gates[_qp][i] = (Real) (*_ionmodel->gates)[i];
    _gates_old[_qp][i] = (Real) (*_ionmodel->gates)[i];
  }
}

void
Electrocardio::computeProperties()
{
  Material::computeProperties();
}

/**
 * @todo documentation
 */
void
Electrocardio::computeQpProperties()
{
  
  // Copy old gates values into local gates vector
  for (int i=0; i<_ionmodel->get_ngates(); ++i) {
    gates_qp[i] = _gates_old[_qp][i];
  }
  
  // Compute ionforcing
  _Iion[_qp] = _ionmodel->ionforcing(_vmem[_qp]);
  
  // Compute time derivative of gating variables
  _ionmodel->update_gates_dt(_vmem[_qp]);
  
  for (int i=0; i<_ionmodel->get_ngates(); ++i) {

    // Forward Euler update step
    gates_qp[i] += _dt*gates_dt_qp[i];
    
    // put updated local values back into global vector
    _gates[_qp][i] = gates_qp[i];
  }
  
  
  
  /**
   * The mono domain equations reads
   *
   * V_t + div( G grad(V)) = I_ion(V)
   *
   * where G is a conductivity tensor, I_ion the current [unit Ampere] generated by the membrane potential V [unit Volt].
   * The ODE for the membrane states S reads
   *
   * S_t = Z(V,S)
   *
   * with V being the membrane potential. 
   * The dependance of I_ion on V and the evolution of the state variables S is given by some membrane model, e.g. Bernus.
   *
   * In propag, the following names are used
   *
   * Vmem = V = membrane potential = variable in reaction-diffusion PDE
   * Iion = I_ion(V) = ion current = reaction term in PDE
   * Imem = diffusion current = div( G grad(V))
   * yyy  = S = cell states = variable in the ODE
   */
  
}
